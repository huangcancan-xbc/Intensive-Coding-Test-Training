为了能够更直观地理解约瑟夫环问题的三种解法（环形链表模拟、数组模拟、动态规划），我找到了几个交互式可视化工具以及动画演示：

>[你应该站在哪个位置，才能活到最后？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KM4y1V7tQ/?spm_id_from = 333.337.search-card.all.click&vd_source = 47fe2fe2f10c4e806e38c62553037767)	[生死逃杀——约瑟夫环，不容错过的经典博弈!_游戏热门视频](https://www.bilibili.com/video/BV1jhXaY4EWV/?spm_id_from = 333.337.search-card.all.click&vd_source = 47fe2fe2f10c4e806e38c62553037767)

### 方法一：环形链表模拟

**可视化工具：**

-   **GeoGebra Josephus Problem Simulation**：GeoGebra 提供了一个交互式的约瑟夫问题模拟器，你可以设置人数和跳数，观察每次删除的过程。
     👉 [点击进入 GeoGebra Josephus Problem Simulation](https://www.geogebra.org/m/ExvvrBbR)
-   **GitHub 项目：Josephus Problem Simulation**：这是一个基于网页的模拟器，展示了每次删除的过程，适合用于理解链表模拟的删除操作。
     👉 [点击进入 Josephus Problem Simulation](https://imakp.github.io/josephus_problem/)

### 方法二：数组模拟

数组模拟的过程不如链表直观，但你可以通过以下了解其实现方式：

**CSDN 博客：学习笔记之约瑟夫环的两种实现方法(数组&链表)**：👉 [点击阅读博客](https://blog.csdn.net/defs6497/article/details/101877979)

### 方法三：动态规划（数学递推）

动态规划方法主要依赖数学公式进行计算，过程较为抽象，不太适合用动画展示。但你可以通过以下资源深入理解其原理：

**OI Wiki：约瑟夫问题**： 👉 [点击阅读 OI Wiki](https://oi-wiki.org/misc/josephus/)

### 动画演示

**Imgur 动图：The Josephus Problem**：这是一张展示约瑟夫问题过程的动图，能够更直观地理解每次删除的顺序。
 👉 [点击查看动图](https://imgur.com/gallery/oAg3GCL)

---

![image-20250504165638868](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250504165646065.png)

-   **res：表示当前规模下的「安全位置」（safe position），编号从 `0` 开始。**
-   **i：表示当前人数从 1 递增到 n（相当于从 1 人问题，逐步构造到 n 人问题）。**
-   **k：每次报数的间隔数（即第 k 个人出列）。**

在这段 DP（递推）的写法里，**`i` 并不是在模拟“实际剩余的人数”**，而是在构造规模为 `i` 的子问题（子圈子），它和我们实际从 `n→1` 的“删除过程”是 **相反方向** 的思考：

1.  **实际过程**：从 `n` 个人开始，每次删除 1 人，圈子里人数不断减少，直到剩下 1 人。

2.  **递推构造**：我们先“假设”只有 1 个人时答案 `f(1)=0`（编号从 `0` 开始），然后逐步“增加”到 2 人、3 人……直到 `n` 人，**每一步都用上一步的信息** 来推导下一步：
    $$
    f(i) = (f(i-1) + k) \mod	i
    $$

就像先学会单人过关，再学两人过关，……最后学会 `n` 人过关。

------

### 为什么要这样“反向”构造？

-   **基本情况**：`f(1)=0` 是最简单、显而易见的情况。
-   **递推意义**：我们已经知道了规模为 `i-1` 的安全位置 `f(i-1)`，现在要往圈子里再“加”第 `i` 个人；这时，原来那个安全位置要往后“移动” `k` 步（因为报数跳过 `k` 个人），然后对当前圈子大小 `i` 做 `% i`，就得到了 `f(i)`。

换句话说，**`i` 表示“当前我们构造的圈子里有多少人”**，因此 `i` 要从 1 慢慢“增大”到 `n`。

------

### 形象比喻

想象现在在建一座楼塔：

-   **第一层**（1 个人）最简单，直接把安全位置标记为 0（唯一编号）。
-   **第二层**（2 个人），在已有的小塔基础上“加一层”，再根据“跳 `k` 步”来修正安全位置。
-   **……**
-   **第 `n` 层** 就是原题要的答案。

整个过程是 **从小塔建大的“自底向上”建塔**，而不是去“拆楼”（实际删除）！

------

### 代码对比

```cpp
int res = 0;              // f(1) = 0
for (int i = 2; i <= n; ++i)
{
    // 在“i-1 个人的安全位置”上再向后跳 k 步，
    // 然后 % i 得到“i 个人的安全位置”
    res = (res + k) % i;
}
return res;               // 编号从 0 开始；如要从 1 开始返回 res+1
```

-   `i` 从 **2** 开始也可以（因为 f(1) 已知），也可以从 **1** 开始，效果等价。
-   `% i` 就是把跳过的步数“环回”到当前圈子大小范围内，保证结果依然在 `[0, i-1]`。
