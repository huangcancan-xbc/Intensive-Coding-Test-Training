## 代码背后的核心思想

其实是用 **排列生成 + 剪枝** 来解决「部分有前置要求」的排列问题。

在递归 `dfs(pos)` 中：

-   意思是：我正在安排 **第 pos 个位置**。
-   所以，当前放进去的人，一定是排在比他后面的位置之前的人。

举个例子，假设我们有 `n = 3`，当前 DFS 构造顺序是：

```
dfs(1)：第1个位置放人
dfs(2)：第2个位置放人
dfs(3)：第3个位置放人
```

你放人的时候，只需要判断：

>   当前人 i，如果想排在某个 v [i] 前面，那这个 v [i] **不能已经放过了**（因为放过就是排在我前面了）

所以：

```cpp
if (vis[v[i]])
    return;
```

它的逻辑其实等价于：

-   如果 `v[i]` 已经安排进去了（在更前面的位置），而我现在才来安排 i，那说明我就排在 v [i] 后面了。
-   这和“我想排在 v [i] 前面”矛盾，因此剪枝！

------

## 从「隐式位置顺序」来理解

我们用 DFS 来构造排列 `[x1, x2, x3, ..., xn]`，假设递归中我们放进去的顺序是：

```
pos = 1 --> 放了 3
pos = 2 --> 放了 1
pos = 3 --> 放了 2
```

得到的队列是 `[3, 1, 2]`

现在如果：

```
a[2] = 1，表示 2 想排在 1 前面
```

但 1 出现在第 2 个位置，2 出现在第 3 个位置（后面），就违反了要求 ❌

而你在第 3 步要放 2 的时候会发现：

-   2 想排在 1 前面
-   但 1 已经放了（在前面），所以这时候剪掉这棵分支！

**所以：“位置”其实就是 DFS 构造的先后顺序，谁先放谁就在前面！**

------

## 并不需要明确记录“i 在第几位”

只需要：确保「如果一个人想排在另一个人前面」，那你放他时，**另一个人还没被放进去**，这就相当于：保证前置条件的合法性，只构造合法拓扑顺序！