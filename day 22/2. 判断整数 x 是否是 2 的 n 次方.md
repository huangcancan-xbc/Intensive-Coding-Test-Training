# 判断整数 x 是否是 2 的 n 次方

**判断一个整数是否是 2 的 n 次方，常见的方法主要有两种：暴力法 和 位运算法。**

要判断一个正整数 `x` 是否是 `2^n`，即形如：`1, 2, 4, 8, 16, 32, 64, ...`。这些数的共同特点是：二进制中 **只有一个位是 1，其余全是 0**，比如：

| 十进制 | 二进制 |
| ------ | ------ |
| 1      | 0001   |
| 2      | 0010   |
| 4      | 0100   |
| 8      | 1000   |

## 1. 方法一：暴力法（常规思路）

```cpp
bool isPowerOfTwo(int x)
{
    if (x <= 0)
    {
        return false;
    }

    while (x % 2 == 0)   	    // 如果能整除2
    {
        x /= 2;                 // 除以2
    }

    return x == 1;              // 最后是否变成了1
}
```

**思路直白，但效率较低。**

## 2. 方法二：位运算法（高效！）

**核心思想：2 的 n 次方二进制中只有一个 1，其余为 0。**

### 方法 1：`x & (x - 1)`

```cpp
bool isPowerOfTwo(int x)
{
    return x > 0 && (x & (x - 1)) == 0;
}
```

**原理解释（重要）：假设 `x = 8`，即 `1000（二进制）`，那么 `x - 1 = 7 = 0111（二进制）`**

```text
  x       = 1000
x - 1     = 0111
----------------
x & (x-1) = 0000   ✅ 恰好等于 0
```

所以：

-   只有 **2 的次方数** 才能满足 `x & (x - 1) == 0`
-   其他数，比如 10（二进制 1010）：

```text
  x       = 1010
x - 1     = 1001
----------------
x & (x-1) = 1000   ≠ 0 ❌
```

------

### 方法 2：`x & -x`（即 lowbit）

```cpp
bool isPowerOfTwo(int x)
{
    return x > 0 && (x & -x) == x;
}
```

**原理解释：`-x` 在二进制中是 `x` 的 补码，它会保留最低位的 1，其他清零。所以 `x & -x` 会提取出最右边的那个 1，也叫 `lowbit(x)`。**

| 数值  | 原码        | 反码（对原码除符号位取反） | 补码（反码 + 1） |
| ----- | ----------- | -------------------------- | ---------------- |
| `+10` | `0000 1010` | `0000 1010`                | `0000 1010`      |
| `-10` | `1000 1010` | `1111 0101`                | `1111 0110`      |

**对比示例：**

**情况一：x = 8（1000）**

```text
x       = 1000
-x      = 1000（补码）
x & -x  = 1000  == x   ✅
```

**情况二：x = 10（1010）**

```text
x       = 1010
-x      = 0110
x & -x  = 0010 ≠ x     ❌
```

结论：如果一个数是 `2^n`，那么它只含一个 1，且 `x & -x == x`，否则不等于。

------

## 3. 方法对比总结：

| 方法          | 原理                        | 是否推荐 | 特点                 |
| ------------- | --------------------------- | -------- | -------------------- |
| 暴力除法      | 连续除以 2 看最后是否为 1    | ❌ 不推荐 | 简单但效率低，循环多 |
| `x & (x - 1)` | 清除最低位的 1 是否为 0        | ✅ 推荐   | 高频技巧，写法简单   |
| `x & -x`      | 只保留最低位的 1 是否等于自身 | ✅ 推荐   | lowbit 的延伸        |

------

## 4. 补充实战：输出 1~100 中所有是 2 的幂的数

```cpp
#include <iostream>
using namespace std;

bool isPowerOfTwo(int x)
{
    return x > 0 && (x & (x - 1)) == 0;  // 或用 (x & -x) == x
}

int main()
{
    for (int i = 1; i <= 100; ++i)
    {
        if (isPowerOfTwo(i))
        {
            cout << i << " ";
        }
    }
    return 0;
}
```

**STL 中常见的 `lowbit` 用法（适用于 BIT 树 / 位运算优化）**

```cpp
int lowbit(int x)
{
    return x & (-x);  // 提取最低位的1，用于树状数组等
}
```

